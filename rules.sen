rule BanForbiddenFunctions {
    block system {
        error "The function system() is forbidden due to command injection risks."
    }
    block popen {
        error "The function popen() is forbidden due to command injection risks."
    }
    block _popen {
        error "The function _popen() is forbidden due to command injection risks."
    }
}
rule IntegerOverflowCheck {
    on call safe_malloc(size) {
        if size1 + size2 overflows {
            error "Potential integer overflow in size calculation for safe_malloc."
        }
    }
}
rule FormatStringCheck {
    on call printf() {
        require_literal_format {
            error "First argument to printf must be a string literal to prevent format string vulnerabilities."
        }
    }
}
rule EnforceNullAfterFree {
    on call free() {
        require_null_after {
           error "Dangling pointer risk. Pointer must be nullified after free."
        }
    }
}
rule BanDoubleFree {
    on call free(ptr) {
        require_no_double_free {
            error "You can't free a variable which has been freed."
        }
    }
}
rule FreeUnusedMemory {
    on call malloc(ptr) {
        require_auto_free_unused {
            error "Allocated memory for 'ptr' is not used. Free and nullify to prevent memory leak and dangling pointer."
        }
    }
}
rule TaintAnalysisExample {
    source scanf {
        error "scanf introduces untrusted user data."
    }

    sink strcpy {
        error "strcpy is a dangerous sink for untrusted data."
    }

    sanitizer clean_string {
    }
}
rule CheckNullPointer {
    on access ptr {
        require_not_null {
            error "Accessing a potentially NULL pointer 'ptr'."
        }
    }
}
rule CheckNullPointerAccess {
    on access dangling_ptr {
        require_not_null {
            error "Potential NULL pointer dereference. The pointer 'dangling_ptr' might be NULL here."
        }
    }
}
rule IntegerOverflowCheck {
    on call safe_malloc(size) {
        if size + sizePrime overflows {
            error "Integer overflow may occur in size calculation."
        }
    }
}

rule SmartNullCheck {
    on access smart_ptr {
        require_not_null {
            error "This pointer might be NULL."
        }
    }
}